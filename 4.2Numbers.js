//在 JavaScript 中，我们通过在数字后附加字母 “e”，并指定零的数量来缩短数字
let billion = 1e9;  // 10 亿，字面意思：数字 1 后面跟 9 个 0

alert( 7.3e9 );  // 73 亿（7,300,000,000）

//十六进制，二进制和八进制数字
// 十六进制 数字在 JavaScript 中被广泛用于表示颜色，编码字符以及其他许多东西。所以自然地，有一种较短的写方法：0x，然后是数字。
//
// 例如：
//
// alert( 0xff ); // 255
// alert( 0xFF ); // 255（一样，大小写没影响）
// 二进制和八进制数字系统很少使用，但也支持使用 0b 和 0o 前缀：
//
// let a = 0b11111111; // 二进制形式的 255
// let b = 0o377; // 八进制形式的 255
//
// alert( a == b ); // true，两边是相同的数字，都是 255
// 只有这三种进制支持这种写法。对于其他进制，我们应该使用函数 parseInt

//toString(base)
// 方法 num.toString(base) 返回在给定 base 进制数字系统中 num 的字符串表示形式。
//
// 举个例子：
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111

//常见的用例如下：
//
// base=16 用于十六进制颜色，字符编码等，数字可以是 0..9 或 A..F。
//
// base=2 主要用于调试按位操作，数字可以是 0 或 1。
//
// base=36 是最大进制，数字可以是 0..9 或 A..Z。所有拉丁字母都被用于了表示数字。对于 36 进制来说，一个有趣且有用的例子是，当我们需要将一个较长的数字标识符转换成较短的时候，例如做一个短的 URL。可以简单地使用基数为 36 的数字系统表示：
alert( 123456..toString(36) ); // 2n9c

//使用两个点来调用一个方法
// 请注意 123456..toString(36) 中的两个点不是打错了。如果我们想直接在一个数字上调用一个方法，比如上面例子中的 toString，那么我们需要在它后面放置两个点 ..。
//
// 如果我们放置一个点：123456.toString(36)，那么就会出现一个 error，因为 JavaScript 语法隐含了第一个点之后的部分为小数部分。如果我们再放一个点，那么 JavaScript 就知道小数部分为空，现在使用该方法。
//
// 也可以写成 (123456).toString(36)


//舍入
// 舍入（rounding）是使用数字时最常用的操作之一。
//
// 这里有几个对数字进行舍入的内建函数：
//
// Math.floor
// 向下舍入：3.1 变成 3，-1.1 变成 -2。
// Math.ceil
// 向上舍入：3.1 变成 4，-1.1 变成 -1。
// Math.round
// 向最近的整数舍入：3.1 变成 3，3.6 变成 4，-1.1 变成 -1。
// Math.trunc（IE 浏览器不支持这个方法）
// 移除小数点后的所有内容而没有舍入：3.1 变成 3，-1.1 变成 -1




//果我们想将数字舍入到小数点后 n 位，该怎么办？
//
// 例如，我们有 1.2345，并且想把它舍入到小数点后两位，仅得到 1.23。
//
// 有两种方式可以实现这个需求：


//乘除法
//
// 例如，要将数字舍入到小数点后两位，我们可以将数字乘以 100（或更大的 10 的整数次幂），调用舍入函数，然后再将其除回。
let num = 1.23456;

alert( Math.floor(num * 100) / 100 ); // 1.23456 -> 123.456 -> 123 -> 1.23

//函数 toFixed(n) 将数字舍入到小数点后 n 位，并以字符串形式返回结果。
let num = 12.34;
alert( num.toFixed(1) ); // "12.3"

//这会向上或向下舍入到最接近的值，类似于 Math.round：
let num = 12.36;
alert( num.toFixed(1) ); // "12.4"
//请注意 toFixed 的结果是一个字符串。如果小数部分比所需要的短，则在结尾添加零：
let num = 12.34;
alert( num.toFixed(5) ); // "12.34000"，在结尾添加了 0，以达到小数点后五位


//不精确的计算
// 在内部，数字是以 64 位格式 IEEE-754 表示的，所以正好有 64 位可以存储一个数字：其中 52 位被用于存储这些数字，其中 11 位用于存储小数点的位置（对于整数，它们为零），而 1 位用于符号。
//
// 如果一个数字太大，则会溢出 64 位存储，并可能会导致无穷大：
//
// alert( 1e500 ); // Infinity
// 这可能不那么明显，但经常会发生的是，精度的损失。
//
// 考虑下这个（falsy！）测试：
//
// alert( 0.1 + 0.2 == 0.3 ); // false
// 没错，如果我们检查 0.1 和 0.2 的总和是否为 0.3，我们会得到 false。
//
// 奇了怪了！如果不是 0.3，那能是啥？
//
// alert( 0.1 + 0.2 ); // 0.30000000000000004
// 哎哟！这个错误比不正确的比较的后果更严重。想象一下，你创建了一个电子购物网站，如果访问者将价格为 ¥ 0.10 和 ¥ 0.20 的商品放入了他的购物车。订单总额将是 ¥ 0.30000000000000004。这会让任何人感到惊讶。
//
// 但为什么会这样呢？
//
// 一个数字以其二进制的形式存储在内存中，一个 1 和 0 的序列。但是在十进制数字系统中看起来很简单的 0.1，0.2 这样的小数，实际上在二进制形式中是无限循环小数。
//
// 换句话说，什么是 0.1？0.1 就是 1 除以 10，1/10，即十分之一。在十进制数字系统中，这样的数字表示起来很容易。将其与三分之一进行比较：1/3。三分之一变成了无限循环小数 0.33333(3)。
//
// 在十进制数字系统中，可以保证以 10 的整数次幂作为除数能够正常工作，但是以 3 作为除数则不能。也是同样的原因，在二进制数字系统中，可以保证以 2 的整数次幂作为除数时能够正常工作，但 1/10 就变成了一个无限循环的二进制小数。
//
// 使用二进制数字系统无法 精确 存储 0.1 或 0.2，就像没有办法将三分之一存储为十进制小数一样。
//
// IEEE-754 数字格式通过将数字舍入到最接近的可能数字来解决此问题。这些舍入规则通常不允许我们看到“极小的精度损失”，但是它确实存在。
//
// 我们可以看到：
//
// alert( 0.1.toFixed(20) ); // 0.10000000000000000555
// 当我们对两个数字进行求和时，它们的“精度损失”会叠加起来。
//
// 这就是为什么 0.1 + 0.2 不等于 0.3。
//
// 不仅仅是 JavaScript
// 许多其他编程语言也存在同样的问题。
//
// PHP，Java，C，Perl，Ruby 给出的也是完全相同的结果，因为它们基于的是相同的数字格式。

//我们能解决这个问题吗？当然，最可靠的方法是借助方法 toFixed(n) 对结果进行舍入：
let sum = 0.1 + 0.2;
alert( sum.toFixed(2) ); // 0.30